#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct clientData {
    unsigned int acctNum;
    char lastName[15];
    char firstName[10];
    char pin[7];  // 6-digit PIN + null terminator
    double balance;
    double totalDeposited;
    double totalWithdrawn;
};

unsigned int enterChoice(void);
void textFile(FILE *readPtr);
void updateRecord(FILE *fPtr);
void newRecord(FILE *fPtr);
void deleteRecord(FILE *fPtr);
void searchByName(FILE *fPtr);
void listByBalance(FILE *fPtr);
void exportActiveAccounts(FILE *fPtr);
void accountSummary(FILE *fPtr);
int verifyPIN(FILE *fPtr, unsigned int account);
void encryptPIN(char *pin, char *encrypted);
void decryptPIN(char *encrypted, char *decrypted);
void deleteAccountsWithoutPIN(FILE *fPtr);

int main(int argc, char *argv[]) {
    FILE *cfPtr;
    unsigned int choice;
    char masterPIN[7];
    const char correctMasterPIN[] = "123456"; // Change this to your desired master PIN
    
    // Master PIN verification
    printf("=== BANKING SYSTEM ACCESS ===\n");
    printf("Enter Master PIN: ");
    scanf("%6s", masterPIN);
    
    if (strcmp(masterPIN, correctMasterPIN) != 0) {
        printf("Access Denied! Incorrect Master PIN.\n");
        exit(EXIT_FAILURE);
    }
    
    printf("Access Granted! Welcome to the Banking System.\n\n");

    if ((cfPtr = fopen("credit.dat", "rb+")) == NULL) {
        printf("%s: File could not be opened.\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    while ((choice = enterChoice()) != 8) {
        switch (choice) {
            case 1: updateRecord(cfPtr); textFile(cfPtr); break;
            case 2: newRecord(cfPtr); textFile(cfPtr); break;
            case 3: deleteRecord(cfPtr); textFile(cfPtr); break;
            case 4: searchByName(cfPtr); textFile(cfPtr); break;
            case 5: listByBalance(cfPtr); textFile(cfPtr); break;
            case 6: exportActiveAccounts(cfPtr); textFile(cfPtr); break;
            case 7: accountSummary(cfPtr); textFile(cfPtr); break;
            default: puts("Incorrect choice"); break;
        }
    }

    fclose(cfPtr);
    return 0;
}

unsigned int enterChoice(void) {
    unsigned int menuChoice;
    printf("\nEnter your choice\n"
           "1 - update an account\n"
           "2 - add a new account\n"
           "3 - delete an account\n"
           "4 - search by name\n"
           "5 - list accounts by balance threshold\n"
           "6 - export only active accounts\n"
           "7 - show account summary\n"
           "8 - end program\n?");
    scanf("%u", &menuChoice);
    return menuChoice;
}

void textFile(FILE *readPtr) {
    FILE *writePtr;
    struct clientData client = {0, "", "", "", 0.0, 0.0, 0.0};

    if ((writePtr = fopen("accounts.txt", "w")) == NULL) {
        puts("File could not be opened.");
        return;
    }

    rewind(readPtr);
    fprintf(writePtr, "%-6s%-16s%-11s%10s%12s%12s\n", "Acct", "Last Name", "First Name", "Balance", "Deposited", "Withdrawn");

    while (fread(&client, sizeof(client), 1, readPtr)) {
        if (client.acctNum != 0) {
            fprintf(writePtr, "%-6d%-16s%-11s%10.2f%12.2f%12.2f\n",
                    client.acctNum, client.lastName, client.firstName, 
                    client.balance, client.totalDeposited, client.totalWithdrawn);
        }
    }

    fclose(writePtr);
}

void updateRecord(FILE *fPtr) {
    unsigned int account;
    double transaction;
    struct clientData client = {0, "", "", "", 0.0, 0.0, 0.0};

    printf("Enter account to update (1 - 2000): ");
    scanf("%d", &account);

    // Verify PIN before allowing update
    if (!verifyPIN(fPtr, account)) {
        return;
    }

    fseek(fPtr, (account - 1) * sizeof(struct clientData), SEEK_SET);
    fread(&client, sizeof(struct clientData), 1, fPtr);

    if (client.acctNum == 0) {
        printf("Account #%d has no information.\n", account);
    } else {
        printf("%-6d%-16s%-11s%10.2f%12.2f%12.2f\n\n", 
               client.acctNum, client.lastName, client.firstName, 
               client.balance, client.totalDeposited, client.totalWithdrawn);
        
        printf("Enter deposit (+) or withdrawal (-): ");
        scanf("%lf", &transaction);
        
        // Track deposits and withdrawals separately
        if (transaction > 0) {
            client.totalDeposited += transaction;
            printf("Deposit of %.2f recorded.\n", transaction);
        } else if (transaction < 0) {
            client.totalWithdrawn += (-transaction);
            printf("Withdrawal of %.2f recorded.\n", -transaction);
        }
        
        client.balance += transaction;
        printf("%-6d%-16s%-11s%10.2f%12.2f%12.2f\n", 
               client.acctNum, client.lastName, client.firstName, 
               client.balance, client.totalDeposited, client.totalWithdrawn);

        fseek(fPtr, (account - 1) * sizeof(struct clientData), SEEK_SET);
        fwrite(&client, sizeof(struct clientData), 1, fPtr);
    }
}

void deleteRecord(FILE *fPtr) {
    struct clientData client, blankClient = {0, "", "", "", 0.0, 0.0, 0.0};
    unsigned int accountNum;

    printf("Enter account number to delete (1 - 2000): ");
    scanf("%d", &accountNum);

    // Verify PIN before allowing deletion
    if (!verifyPIN(fPtr, accountNum)) {
        return;
    }

    fseek(fPtr, (accountNum - 1) * sizeof(struct clientData), SEEK_SET);
    fread(&client, sizeof(struct clientData), 1, fPtr);

    if (client.acctNum == 0) {
        printf("Account %d does not exist.\n", accountNum);
    } else {
        fseek(fPtr, (accountNum - 1) * sizeof(struct clientData), SEEK_SET);
        fwrite(&blankClient, sizeof(struct clientData), 1, fPtr);
        printf("Account %d deleted successfully.\n", accountNum);
    }
}

void newRecord(FILE *fPtr) {
    struct clientData client = {0, "", "", "", 0.0, 0.0, 0.0};
    unsigned int accountNum;

    printf("Enter new account number (1 - 2000): ");
    scanf("%d", &accountNum);

    fseek(fPtr, (accountNum - 1) * sizeof(struct clientData), SEEK_SET);
    fread(&client, sizeof(struct clientData), 1, fPtr);

    if (client.acctNum != 0) {
        printf("Account #%d already contains information.\n", client.acctNum);
    } else {
        printf("Enter firstname: ");
        scanf("%9s", client.firstName);
        printf("Enter lastname: ");
        scanf("%14s", client.lastName);
        char tempPIN[7];
        printf("Enter 6-digit PIN: ");
        scanf("%6s", tempPIN);
        encryptPIN(tempPIN, client.pin);
        printf("Enter initial balance: ");
        scanf("%lf", &client.balance);
        
        client.acctNum = accountNum;
        
        // Initialize deposit/withdrawal tracking
        if (client.balance > 0) {
            client.totalDeposited = client.balance;
            client.totalWithdrawn = 0.0;
        } else {
            client.totalDeposited = 0.0;
            client.totalWithdrawn = -client.balance;
        }
        
        fseek(fPtr, (client.acctNum - 1) * sizeof(struct clientData), SEEK_SET);
        fwrite(&client, sizeof(struct clientData), 1, fPtr);
        printf("Account created successfully.\n");
    }
}

void searchByName(FILE *fPtr) {
    char query[15];
    char lowerQuery[15];
    char lowerFirst[10], lowerLast[15];
    struct clientData client;
    int found = 0;
    int i;

    printf("Enter name to search (partial match supported): ");
    scanf("%14s", query);

    // Convert query to lowercase for case-insensitive search
    for (i = 0; query[i]; i++) {
        lowerQuery[i] = (query[i] >= 'A' && query[i] <= 'Z') ? query[i] + 32 : query[i];
    }
    lowerQuery[i] = '\0';

    printf("\nSearch Results (partial & case-insensitive):\n");
    printf("%-6s%-16s%-11s%10s%12s%12s\n", "Acct", "Last Name", "First Name", "Balance", "Deposited", "Withdrawn");
    printf("----------------------------------------------------------------------\n");

    rewind(fPtr);
    while (fread(&client, sizeof(client), 1, fPtr) == 1) {
        if (client.acctNum != 0) {
            // Convert client names to lowercase for comparison
            for (i = 0; client.firstName[i]; i++) {
                lowerFirst[i] = (client.firstName[i] >= 'A' && client.firstName[i] <= 'Z') ? 
                               client.firstName[i] + 32 : client.firstName[i];
            }
            lowerFirst[i] = '\0';
            
            for (i = 0; client.lastName[i]; i++) {
                lowerLast[i] = (client.lastName[i] >= 'A' && client.lastName[i] <= 'Z') ? 
                              client.lastName[i] + 32 : client.lastName[i];
            }
            lowerLast[i] = '\0';
            
            // Check for partial match in either first or last name
            if (strstr(lowerFirst, lowerQuery) != NULL || strstr(lowerLast, lowerQuery) != NULL) {
                printf("%-6d%-16s%-11s%10.2f%12.2f%12.2f\n",
                       client.acctNum, client.lastName, client.firstName, 
                       client.balance, client.totalDeposited, client.totalWithdrawn);
                found = 1;
            }
        }
    }

    if (!found) puts("No matching records found.");
}

void listByBalance(FILE *fPtr) {
    double threshold;
    char direction, sortOrder;
    struct clientData client;
    struct clientData matchingAccounts[2000];
    int found = 0, count = 0, i, j;
    struct clientData temp;

    printf("Enter balance threshold: ");
    scanf("%lf", &threshold);
    printf("List accounts with balance (above: 'a' / below: 'b'): ");
    scanf(" %c", &direction);
    printf("Sort by balance (ascending: 'a' / descending: 'd'): ");
    scanf(" %c", &sortOrder);

    // First pass: collect matching accounts
    rewind(fPtr);
    while (fread(&client, sizeof(client), 1, fPtr) == 1) {
        if (client.acctNum != 0 &&
            ((direction == 'a' && client.balance > threshold) ||
             (direction == 'b' && client.balance < threshold))) {
            matchingAccounts[count] = client;
            count++;
            found = 1;
        }
    }

    if (!found) {
        puts("No accounts match the criteria.");
        return;
    }

    // Sort the matching accounts by balance
    for (i = 0; i < count - 1; i++) {
        for (j = 0; j < count - i - 1; j++) {
            int shouldSwap = 0;
            if (sortOrder == 'a') {
                // Ascending order
                shouldSwap = (matchingAccounts[j].balance > matchingAccounts[j + 1].balance);
            } else {
                // Descending order
                shouldSwap = (matchingAccounts[j].balance < matchingAccounts[j + 1].balance);
            }
            
            if (shouldSwap) {
                temp = matchingAccounts[j];
                matchingAccounts[j] = matchingAccounts[j + 1];
                matchingAccounts[j + 1] = temp;
            }
        }
    }

    // Display sorted results
    printf("\nFiltered & Sorted Results (%s by balance):\n", 
           sortOrder == 'a' ? "Ascending" : "Descending");
    printf("%-6s%-16s%-11s%10s%12s%12s\n", "Acct", "Last Name", "First Name", "Balance", "Deposited", "Withdrawn");
    printf("----------------------------------------------------------------------\n");

    for (i = 0; i < count; i++) {
        printf("%-6d%-16s%-11s%10.2f%12.2f%12.2f\n",
               matchingAccounts[i].acctNum, matchingAccounts[i].lastName, 
               matchingAccounts[i].firstName, matchingAccounts[i].balance, 
               matchingAccounts[i].totalDeposited, matchingAccounts[i].totalWithdrawn);
    }
    
    printf("\nTotal accounts found: %d\n", count);
}

void exportActiveAccounts(FILE *fPtr) {
    FILE *out = fopen("active_accounts.txt", "w");
    if (!out) {
        perror("Error opening output file");
        return;
    }

    struct clientData client;
    int count = 0;
    
    rewind(fPtr);
    fprintf(out, "%-6s%-16s%-11s%10s%12s%12s\n", "Acct", "Last Name", "First Name", "Balance", "Deposited", "Withdrawn");
    fprintf(out, "----------------------------------------------------------------------\n");

    while (fread(&client, sizeof(client), 1, fPtr) == 1) {
        if (client.acctNum != 0 && client.balance != 0.0) {
            fprintf(out, "%-6d%-16s%-11s%10.2f%12.2f%12.2f\n",
                    client.acctNum, client.lastName, client.firstName, 
                    client.balance, client.totalDeposited, client.totalWithdrawn);
            count++;
        }
    }

    fclose(out);
    printf("Exported %d active accounts to active_accounts.txt.\n", count);
}

void accountSummary(FILE *fPtr) {
    struct clientData client;
    int total = 0, active = 0, positiveBalance = 0, negativeBalance = 0;
    double totalBalance = 0.0, totalDeposited = 0.0, totalWithdrawn = 0.0;

    rewind(fPtr);
    while (fread(&client, sizeof(client), 1, fPtr) == 1) {
        if (client.acctNum != 0) {
            total++;
            if (client.balance != 0.0)
                active++;
            if (client.balance > 0)
                positiveBalance++;
            else if (client.balance < 0)
                negativeBalance++;
                
            totalBalance += client.balance;
            totalDeposited += client.totalDeposited;
            totalWithdrawn += client.totalWithdrawn;
        }
    }

    printf("\n=== ACCOUNT SUMMARY ===\n");
    printf("Total Accounts        : %d\n", total);
    printf("Active Accounts       : %d\n", active);
    printf("Positive Balance Accts: %d\n", positiveBalance);
    printf("Negative Balance Accts: %d\n", negativeBalance);
    printf("\n=== FINANCIAL SUMMARY ===\n");
    printf("Total Balance         : $%.2f\n", totalBalance);
    printf("Total Deposited       : $%.2f\n", totalDeposited);
    printf("Total Withdrawn       : $%.2f\n", totalWithdrawn);
    printf("Net Activity          : $%.2f\n", totalDeposited - totalWithdrawn);
    
    if (total > 0) {
        printf("Average Balance       : $%.2f\n", totalBalance / total);
        printf("Average Deposited     : $%.2f\n", totalDeposited / total);
        printf("Average Withdrawn     : $%.2f\n", totalWithdrawn / total);
    }
}

int verifyPIN(FILE *fPtr, unsigned int account) {
    struct clientData client = {0, "", "", "", 0.0, 0.0, 0.0};
    char enteredPIN[7];
    
    fseek(fPtr, (account - 1) * sizeof(struct clientData), SEEK_SET);
    fread(&client, sizeof(struct clientData), 1, fPtr);
    
    if (client.acctNum == 0) {
        printf("Account #%d does not exist.\n", account);
        return 0;
    }
    
    printf("Enter PIN for account #%d: ", account);
    scanf("%6s", enteredPIN);
    
    char decryptedPIN[7];
    decryptPIN(client.pin, decryptedPIN);
    
    if (strcmp(decryptedPIN, enteredPIN) == 0) {
        return 1; // PIN correct
    } else {
        printf("Incorrect PIN!\n");
        return 0; // PIN incorrect
    }
}

// Simple XOR encryption for PINs
void encryptPIN(char *pin, char *encrypted) {
    const char key = 0x5A; // Encryption key (can be changed)
    int i;
    
    for (i = 0; pin[i] != '\0'; i++) {
        encrypted[i] = pin[i] ^ key;
    }
    encrypted[i] = '\0';
}

// Simple XOR decryption for PINs
void decryptPIN(char *encrypted, char *decrypted) {
    const char key = 0x5A; // Same key used for encryption
    int i;
    
    for (i = 0; encrypted[i] != '\0'; i++) {
        decrypted[i] = encrypted[i] ^ key;
    }
    decrypted[i] = '\0';
}

// Delete all accounts without PINs (cleanup old accounts)
void deleteAccountsWithoutPIN(FILE *fPtr) {
    struct clientData client, blankClient = {0, "", "", "", 0.0, 0.0, 0.0};
    int count = 0;

    printf("Cleaning up accounts without PINs...\n");
    
    for (int i = 0; i < 2000; i++) {
        fseek(fPtr, i * sizeof(struct clientData), SEEK_SET);
        fread(&client, sizeof(struct clientData), 1, fPtr);

        if (client.acctNum != 0 && client.pin[0] == '\0') {
            fseek(fPtr, i * sizeof(struct clientData), SEEK_SET);
            fwrite(&blankClient, sizeof(struct clientData), 1, fPtr);
            count++;
        }
    }

    printf("Deleted %d account(s) with no PIN.\n", count);
}
